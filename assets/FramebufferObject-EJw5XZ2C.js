import{ky as C,dt as p,bF as y,kz as o,fR as d,fQ as T,kA as E,dC as F,kB as U,kC as R,kD as N,kE as b,kF as A,bf as B}from"./index-Bkom2Sdc.js";import{o as M}from"./BufferObject-CTARDp2h.js";class k{constructor(t,r=0,e=r,i=!1,n=1){this.internalFormat=t,this.width=r,this.height=e,this.multisampled=i,this.samples=n}}function z(s){return s.width<=0||s.height<=0||s.internalFormat==null?0:s.width*s.height*C(s.internalFormat)}const P=!!y("esri-tests-disable-gpu-memory-measurements");class w{constructor(t,r){this._context=t,this._descriptor=r,this.type=2,this._context.instanceCounter.increment(p.Renderbuffer,this);const e=this._context.gl;this.glName=e.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:i,height:n,internalFormat:h,multisampled:a}=r;a?e.renderbufferStorageMultisample(e.RENDERBUFFER,this.samples,h,i,n):e.renderbufferStorage(e.RENDERBUFFER,h,i,n),this._context.bindRenderbuffer(null)}get descriptor(){return this._descriptor}get samples(){const t=this._descriptor.samples,r=this._context.parameters.maxSamples;return t?Math.min(t,r):r}get usedMemory(){return P?0:z(this._descriptor)}resize(t,r){const e=this._descriptor;if(e.width===t&&e.height===r)return;e.width=t,e.height=r;const i=this._context.gl;this._context.bindRenderbuffer(this),e.multisampled?i.renderbufferStorageMultisample(i.RENDERBUFFER,this.samples,e.internalFormat,e.width,e.height):i.renderbufferStorage(i.RENDERBUFFER,e.internalFormat,e.width,e.height),this._context.bindRenderbuffer(null)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(p.Renderbuffer,this),this._context=null)}}const v=()=>B.getLogger("esri.views.webgl.FramebufferObject");var c;let G=(c=class{constructor(t,r,e){if(this._context=t,this._glName=null,this._colorAttachments=new Map,this._depthStencilBuffer=null,this._depthStencilTexture=null,this._initialized=!1,t.instanceCounter.increment(p.FramebufferObject,this),r!=null){const i=H(t,r);i!=null&&(this._colorAttachments.set(o,i),l(i)?this._validateTextureDescriptor(i.descriptor):this._validateRenderbufferDescriptor(i.descriptor)),this._validateColorAttachmentPoint(o)}if(e!=null)if(L(e))this._depthStencilTexture=l(e)?e:new d(t,e),this._validateTextureDescriptor(this._depthStencilTexture.descriptor);else{const i=S(e)?e:new w(t,e);this._depthStencilBuffer=i,this._validateRenderbufferDescriptor(i.descriptor)}}dispose(){const{_colorAttachments:t,_glName:r}=this;if(t.size===0&&!this._depthStencilBuffer&&!this._depthStencilTexture&&!r)return;const{_context:e}=this,i=e.getBoundFramebufferObject();t.forEach((n,h)=>this.detachColorTexture(h)?.dispose()),this.detachDepthStencilBuffer()?.dispose(),this.detachDepthStencilTexture()?.dispose(),e.gl.deleteFramebuffer(r),this._glName=null,e.bindFramebuffer(i===this?null:i),e.instanceCounter.decrement(p.FramebufferObject,this)}get glName(){return this._glName}get colorTexture(){const t=this._colorAttachments.get(o);return l(t)?t:null}get depthStencil(){return this._depthStencilTexture||this._depthStencilBuffer}get depthStencilTexture(){return this._depthStencilTexture}get width(){return(this._colorAttachments.get(o)??this._depthStencilTexture??this._depthStencilBuffer)?.descriptor?.width??0}get height(){return(this._colorAttachments.get(o)??this._depthStencilTexture??this._depthStencilBuffer)?.descriptor?.height??0}get usedMemory(){return[...this._colorAttachments].reduce((t,[r,e])=>t+e.usedMemory,this.depthStencil?.usedMemory??0)}getColorTexture(t){const r=this._colorAttachments.get(t);return r&&l(r)?r:null}get colorAttachments(){return[...this._colorAttachments.keys()]}attachColorTexture(t,r=o){if(!t)return;this._validateColorAttachmentPoint(r);const{descriptor:e}=t;this._validateTextureDescriptor(e),this.detachColorTexture(r)?.dispose(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,r)),this._colorAttachments.set(r,t)}detachColorTexture(t=o){const r=this._colorAttachments.get(t);if(!r)return;const e=l(r);return this._initialized&&this._context.temporaryBindFramebufferObject(this,()=>{if(e)this._framebufferTexture2D(null,t);else{const i=this._context.gl;i.framebufferRenderbuffer(i.FRAMEBUFFER,t,i.RENDERBUFFER,null)}}),this._colorAttachments.delete(t),e?r:void 0}setColorTextureTarget(t,r=o,e=0){const i=this._colorAttachments.get(r);i&&(t===35866?this._framebufferTextureLayer(i.glName,r,36160,0,e):this._framebufferTexture2D(i.glName,r,t,36160,0))}attachDepthStencil(t){if(t)switch(t.type){case 1:return this._attachDepthStencilTexture(t);case 2:return this._attachDepthStencilBuffer(t)}}_attachDepthStencilTexture(t){if(t==null)return;const{descriptor:r}=t,{pixelFormat:e,dataType:i}=r;e===34041||e===6402?e!==34041||i===T.UNSIGNED_INT_24_8?e!==6402||i===T.UNSIGNED_INT||i===T.UNSIGNED_SHORT?(this._validateTextureDescriptor(r),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,m(e))),this._depthStencilTexture?.dispose(),this._depthStencilTexture=t):console.error("Depth texture must have data type of UNSIGNED_INT or UNSIGNED_SHORT!"):console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"):console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!")}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&this._context.temporaryBindFramebufferObject(this,()=>{this._framebufferTexture2D(null,m(t.descriptor.pixelFormat))}),this._depthStencilTexture=null,t}_attachDepthStencilBuffer(t){if(t==null)return;const r=t.descriptor;if(this._validateRenderbufferDescriptor(r),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);const{gl:e}=this._context,i=this._getGLAttachmentPoint(r);e.framebufferRenderbuffer(36160,i,e.RENDERBUFFER,t.glName)}this._depthStencilBuffer=t}detachDepthStencilBuffer(){const t=this._depthStencilBuffer;if(t&&this._initialized){const{_context:r}=this,e=r.getBoundFramebufferObject();r.bindFramebuffer(this);const{gl:i}=r,n=this._getGLAttachmentPoint(t.descriptor);i.framebufferRenderbuffer(36160,n,i.RENDERBUFFER,null),r.bindFramebuffer(e)}return this._depthStencilBuffer=null,t}invalidateAttachments(t){const{_context:r}=this;r.temporaryBindFramebufferObject(this,()=>r.gl.invalidateFramebuffer(36160,t),!0)}copyToTexture(t,r,e,i,n,h,a){(t<0||r<0||n<0||h<0)&&console.error("Offsets cannot be negative!"),(e<=0||i<=0)&&console.error("Copy width and height must be greater than zero!");const f=a.descriptor;a.descriptor.target!==3553&&console.error("Texture target must be TEXTURE_2D!"),(f?.width==null||f?.height==null||t+e>this.width||r+i>this.height||n+e>f.width||h+i>f.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const u=this._context,g=u.bindTexture(a,d.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),u.bindFramebuffer(this),u.gl.copyTexSubImage2D(3553,0,n,h,t,r,e,i),u.bindTexture(g,d.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,r,e,i,n,h,a){(e<=0||i<=0)&&console.error("Copy width and height must be greater than zero!"),a||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,r,e,i,n,h,a)}async readPixelsAsync(t,r,e,i,n,h,a){const{gl:f}=this._context,u=M.createPixelPack(this._context,35041,a.byteLength);this._context.bindBuffer(u);const g=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),f.readPixels(t,r,e,i,n,h,0),this._context.unbindBuffer(35051),this._context.bindFramebuffer(g),await u.getSubDataAsync(a),u.dispose()}resize(t,r){if(this.width===t&&this.height===r)return;const e={width:t,height:r};if(_(e,this._context.parameters.maxTextureSize),this._colorAttachments.forEach(i=>i.resize(e.width,e.height)),this._depthStencilTexture?.resize(e.width,e.height),this._initialized&&(_(e,this._context.parameters.maxRenderbufferSize),this._depthStencilBuffer?.resize(e.width,e.height),E())){const{gl:i}=this._context;i.checkFramebufferStatus(36160)!==i.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!")}}initializeAndBind(t=36160){const{gl:r}=this._context;if(this._initialized)return void r.bindFramebuffer(t,this.glName);this._glName&&r.deleteFramebuffer(this._glName);const e=r.createFramebuffer();if(r.bindFramebuffer(t,e),this._colorAttachments.forEach((i,n)=>{if(l(i)){const h=D(i);h===35866?this._framebufferTextureLayer(i.glName,n,t,0,0):this._framebufferTexture2D(i.glName,n,h,t)}else if(S(i)){const h=this._context.gl;h.framebufferRenderbuffer(t,n,h.RENDERBUFFER,i.glName)}}),this._depthStencilBuffer){const i=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);r.framebufferRenderbuffer(t,i,r.RENDERBUFFER,this._depthStencilBuffer.glName)}else if(this._depthStencilTexture){const i=m(this._depthStencilTexture.descriptor.pixelFormat);this._framebufferTexture2D(this._depthStencilTexture.glName,i,D(this._depthStencilTexture),t)}E()&&r.checkFramebufferStatus(t)!==r.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=e,this._initialized=!0}_framebufferTexture2D(t,r=o,e=3553,i=36160,n=0){this._context.gl.framebufferTexture2D(i,r,e,t,n)}_framebufferTextureLayer(t,r=o,e=36160,i=0,n=0){this._context.gl.framebufferTextureLayer(e,r,t,i,n)}_disposeDepthStencilAttachments(){const t=this._context.gl;if(this._depthStencilBuffer){if(this._initialized){this._context.bindFramebuffer(this);const r=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);t.framebufferRenderbuffer(36160,r,t.RENDERBUFFER,null)}this._depthStencilBuffer=F(this._depthStencilBuffer)}this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,m(this._depthStencilTexture.descriptor.pixelFormat))),this._depthStencilTexture=F(this._depthStencilTexture))}_validateTextureDescriptor(t){t.target!==3553&&t.target!==34067&&t.target!==35866&&console.error("Texture type must be TEXTURE_2D, TEXTURE_2D_ARRAY or TEXTURE_CUBE_MAP!"),_(t,this._context.parameters.maxTextureSize),this._validateBufferDimensions(t)}_validateRenderbufferDescriptor(t){_(t,this._context.parameters.maxRenderbufferSize),this._validateBufferDimensions(t)}_validateBufferDimensions(t){t.width<=0&&(t.width=this.width),t.height<=0&&(t.height=this.height),this.width>0&&this.height>0&&(this.width===t.width&&this.height===t.height||console.error("Attachment size must match framebuffer size!"))}_getGLAttachmentPoint(t){switch(t.internalFormat){case b.DEPTH_COMPONENT16:case b.DEPTH_COMPONENT24:case b.DEPTH_COMPONENT32F:return A;case R.DEPTH24_STENCIL8:case R.DEPTH32F_STENCIL8:return N;case 36168:return U;default:return o}}_validateColorAttachmentPoint(t){if(c._MAX_COLOR_ATTACHMENTS===-1){const{gl:e}=this._context;c._MAX_COLOR_ATTACHMENTS=e.getParameter(e.MAX_COLOR_ATTACHMENTS)}const r=t-o;r+1>c._MAX_COLOR_ATTACHMENTS&&B.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${r+1}. Implementation supports up to ${c._MAX_COLOR_ATTACHMENTS} color attachments`)}},c._MAX_COLOR_ATTACHMENTS=-1,c);function l(s){return x(s)===1}function S(s){return x(s)===2}function L(s){return l(s)||O(s)}function O(s){return x(s)===0}function I(s){return x(s)===3||s!=null&&"samples"in s}function x(s){return s!=null&&"type"in s?s.type:null}function H(s,t){return l(t)||S(t)?t:O(t)?new d(s,t):I(t)?new w(s,t):null}function _(s,t){const r=Math.max(s.width,s.height);if(r>t){v().warnOnce(`Resizing FBO attachment size ${s.width}x${s.height} to device limit ${t}`);const e=t/r;return s.width=Math.round(s.width*e),s.height=Math.round(s.height*e),!1}return!0}function D(s){return s.descriptor.target===34067?34069:s.descriptor.target===35866?35866:3553}function m(s){return s===6402?A:N}export{k as i,G as m,w as s};
