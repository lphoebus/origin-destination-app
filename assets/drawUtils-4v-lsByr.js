import{iz as d,d_ as b,iA as P,iB as T,bu as Z,e3 as v,cQ as _,e1 as k,e4 as j,e5 as q,e6 as U,iC as E,iD as F}from"./index-Bkom2Sdc.js";import{c as G}from"./GraphicManipulator-gybNDTVv.js";function R(n,e,i,t){if(n.type==="point")return n.x+=e,n.y+=i,n.hasZ&&t!=null,n;if(n.type==="multipoint"){const r=n.points;for(let o=0;o<r.length;o++)r[o]=w(r[o],e,i,t);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=i,n.ymax+=i,n;const s=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,c=k(n);for(let r=0;r<s.length;r++){const o=s[r];for(let m=0;m<o.length;m++)o[m]=I(o[m],e,i,t)}return"paths"in n?c?n.curvePaths=s:n.paths=s:c?n.curveRings=s:n.rings=s,n}function N(n,e,i,t,s){const c=n.clone();if(s){const{resolution:r}=t;R(c,e*r,-i*r)}else{const{dxMap:r,dyMap:o}=H(e,i,t);R(c,r,o)}return c}function H(n,e,i){const t=i.state.inverseTransform;return{dxMap:t[0]*n+t[2]*e,dyMap:t[1]*n+t[3]*e}}function w(n,e,i,t){return A(n,n[0]+e,n[1]+i,n[2]!=null&&t!=null?n[2]+t:void 0)}function I(n,e,i,t){const s=w(v(n),e,i,t);if(j(n))return s;if(q(n)){const[,o,m]=n.b;return{b:[s,[o[0]+e,o[1]+i],[m[0]+e,m[1]+i]]}}if(U(n)){const[,o]=n.c;return{c:[s,[o[0]+e,o[1]+i]]}}const[,c,...r]=n.a;return{a:[s,[c[0]+e,c[1]+i],...r]}}function O(n,e,i,t){if(n.type==="point"){const{x:u,y:f}=n,y=t?t[0]:u,l=t?t[1]:f,x=n.clone(),p=(u-y)*e+y,a=(f-l)*i+l;return x.x=p,x.y=a,x}if(n.type==="extent"){const{xmin:u,xmax:f,ymin:y,ymax:l}=n,x=t?t[0]:(u+f)/2,p=t?t[1]:(l+y)/2,a=n.clone();if(a.xmin=(u-x)*e+x,a.ymax=(l-p)*i+p,a.xmax=(f-x)*e+x,a.ymin=(y-p)*i+p,a.xmin>a.xmax){const h=a.xmin,M=a.xmax;a.xmin=M,a.xmax=h}if(a.ymin>a.ymax){const h=a.ymin,M=a.ymax;a.ymin=M,a.ymax=h}return a}let s=null;if(!t){s=d(n);const u=b(),f=P(u,s);if(!f)return n.clone();const[y,l,x,p]=f;t=[(y+x)/2,(l+p)/2]}const[c,r]=t;if(n.type==="multipoint"){const u=n.clone(),f=u.points;for(let y=0;y<f.length;y++){const l=f[y],[x,p]=l,a=(x-c)*e+c,h=(p-r)*i+r;f[y]=A(l,a,h,void 0)}return u.points=f,u}const o=n.clone();s??=d(n);const m=o.type==="polygon",g=m?o.curveRings??o.rings:o.curvePaths??o.paths;if(!t){const u=b(),f=P(u,g,!1,!1);if(!f)return o;t=T(f)}for(const u of g){let f=null;const y=m&&u.length>0&&Z(v(u[0]),v(u.at(-1)));for(let l=0;l<u.length;l++){const x=u[l];u[l]=J(x,e,i,c,r,f),f=x}y&&(u[0]=[...v(u.at(-1))])}return o}function z(n,e,i,t,s){const[c,r,...o]=n;return[(c-t)*e+t,(r-s)*i+s,...o]}function J(n,e,i,t,s,c){if(j(n))return z(n,e,i,t,s);if(q(n)){const[B,C,D]=n.b.map(Q=>z(Q,e,i,t,s));return{b:[B,C,D]}}if(!c)return n;const r=v(c),o=U(n)?E(r,n):n,[m,g,u,f,y,l,x]=o.a,p=y??0,a=l??Math.hypot(m[0]-g[0],m[1]-g[1]),h=x??1,M=G(t,s,1,0,0,1,e,i);return F(r,{a:[[...m],[...g],u,f,p,a,h]},M)}function S(n,e,i,t,s,c){const r=Math.sqrt((i-n)*(i-n)+(t-e)*(t-e));return Math.sqrt((s-n)*(s-n)+(c-e)*(c-e))/r}function V(n,e,i,t=!1){const s=Math.atan2(e.y-i.y,e.x-i.x)-Math.atan2(n.y-i.y,n.x-i.x),c=Math.atan2(Math.sin(s),Math.cos(s));return t?c:_(c)}function A(n,e,i,t){const s=[e,i];return n.length>2&&s.push(t??n[2]),n.length>3&&s.push(n[3]),s}export{O as M,S as U,V as b,H as h,N as x};
