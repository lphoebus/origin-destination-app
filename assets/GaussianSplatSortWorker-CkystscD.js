class M{constructor(e,s,i,c=!1){this.distances=e,this.sortOrderIndices=s,this.numGaussians=i,this.preciseSort=c}}class d{constructor(e,s){this.distances=e,this.sortedOrderIndices=s}}let u=null,o=null;const m=10,p=20,y=.25;function g(r,e){u?.length!==r&&(u=new Uint32Array(r)),o&&o.length===1+(1<<e)?o.fill(0):o=new Uint32Array(1+(1<<e))}function b(r,e){const s=r.length,i=Math.max(m,Math.min(p,Math.round(Math.log2(s/y)))),c=1+(1<<i);g(s,i);let a=r[0],l=r[0];for(let t=0;t<r.length;t++)a=Math.min(a,r[t]),l=Math.max(l,r[t]);const f=l-a;if(f<1e-6)for(let t=0;t<s;++t)u[t]=0,o[0]++;else{const t=(1<<i)/f;for(let n=0;n<s;n++){const h=(r[n]-a)*t>>>0;u[n]=h,o[h]++}}for(let t=1;t<c;t++)o[t]+=o[t-1];for(let t=0;t<s;t++){const n=u[t];e[--o[n]]=t}}async function S(r){const{distances:e,sortOrderIndices:s,preciseSort:i,numGaussians:c}=r,a=e.subarray(0,c),l=s.subarray(0,c);if(a.length===0||l.length===0)return{result:new d(e,s),transferList:[e.buffer,s.buffer]};if(i){const f=Array.from(l.keys());f.sort((n,h)=>a[n]-a[h]||n-h);const t=f.map(n=>l[n]);l.set(t)}else b(a,l);return{result:new d(e,s),transferList:[e.buffer,s.buffer]}}function w(){u=null,o=null}export{M as SplatSortWorkerInput,d as SplatSortWorkerOutput,w as destroy,S as sort};
