import{b6 as d,b8 as r,ba as u,bb as y,b4 as m,fg as N,aY as f,b7 as F}from"./index-Bkom2Sdc.js";import{n as P}from"./locationUtils-BHxEwK9e.js";import{d as h,w as v,g as k}from"./parquet-B574Roxs.js";let a=class extends d{constructor(n){super(n),this.type="location",this.latitudeFieldName=null,this.longitudeFieldName=null}};r([u({type:["location"],readOnly:!0,json:{write:!0}})],a.prototype,"type",void 0),r([u({json:{write:!0}})],a.prototype,"latitudeFieldName",void 0),r([u({json:{write:!0}})],a.prototype,"longitudeFieldName",void 0),a=r([y("esri.layers.support.ParquetEncodingLocation")],a);let l=class extends d{constructor(t){super(t),this.type="wkb",this.primaryFieldName=null}};r([u({type:["wkb"],readOnly:!0,json:{write:!0}})],l.prototype,"type",void 0),r([u({json:{write:!0}})],l.prototype,"orientation",void 0),r([u({json:{write:!0}})],l.prototype,"primaryFieldName",void 0),l=r([y("esri.layers.support.ParquetEncodingWkb")],l);const g=new F({esriGeometryPoint:"point",esriGeometryPolygon:"polygon",esriGeometryPolyline:"polyline",esriGeometryMultipoint:"multipoint"});function G(t){return g.toJSON(t)}function R(t){return g.fromJSON(t)}async function _(t,n={}){if(t.geometryType&&t.spatialReference&&t.encoding&&t.fields)return t;if(t.urls.length<1)throw new m("parquet:bad-input","At least one url must be specified",t);const o=await h(t.urls.getItemAt(0),{getCustomParameters:()=>n.customParameters}),i=v(o),e={...t,file:o};e.fields==null&&(e.fields=o.fields().map(s=>N.fromJSON({name:s.name,type:s.type}))),e.encoding==null&&(e.encoding=z(i,e.fields));const p=k(o);if(p)switch(p.mode){case"z":e.displayOptimization={mode:"z"};break;case"xz":{const s=p.multiscale;if(!s)throw new m("bad-format","XZ display optimization requires multiscale geometries");e.displayOptimization={mode:"xz",multiscale:s};break}}if(!e.encoding)return e;switch(e.encoding.type){case"location":e.spatialReference==null&&(e.spatialReference=f.WGS84),e.geometryType==null&&(e.geometryType="point");break;case"wkb":{if(!i)return e;const s=i.primary_column,c=i.columns[s];if(e.geometryType||(e.geometryType=j(c)),e.spatialReference||(e.spatialReference=x(c)),e.fields)for(const w of Object.keys(i.columns))e.fields=e.fields.filter(b=>b.name!==w)}}return e}function z(t,n){if(t!=null){const i=t.primary_column,e=t.columns[i];return new l({primaryFieldName:i,orientation:e.orientation??null})}const o=P(n.map(i=>i.name));return o.latitudeFieldName&&o.latitudeFieldName?new a({latitudeFieldName:o.latitudeFieldName,longitudeFieldName:o.longitudeFieldName}):null}function O(t){switch(t){case"Point":return"point";case"Polygon":case"MultiPolygon":return"polygon";case"LineString":return"polyline";case"MultiPoint":return"multipoint";default:return null}}function j(t){const{geometry_types:n}=t,o=new Set;for(const i of n){const e=O(i);e&&o.add(e)}if(o.size>1)throw new m("unsupported","Parquet mixed geometry types are not support",{geometryTypes:o});return o.size===1?o.values().next().value:void 0}function x(t){const n=t.crs?.id?.code;return n&&typeof n=="number"?new f({wkid:n}):void 0}export{l as a,R as f,G as p,a as s,_ as y};
