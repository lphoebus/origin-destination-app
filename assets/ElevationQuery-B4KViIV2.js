import{nJ as se,ka as V,pt as Z,fx as oe,gW as re,bf as G,a$ as ce,b8 as p,bb as $,jd as N,aY as ue,d_ as fe,fI as D,lB as he,ba as T,b4 as d,gf as U,gh as B,l4 as me,d6 as J,iP as b,lT as pe,bU as Y}from"./index-Bkom2Sdc.js";import{r as R}from"./GeometryDescriptor-UaZr_uMV.js";class H{constructor(t,i){this.layer=t,this.parameters=i}}let de=class extends H{constructor(t,i,n){super(t,n),this.outSpatialReference=i,this.type="geometry"}selectTilesAtLOD(t){if(t<0)this.geometry.coordinates.forEach(i=>i.tile=null);else{const{tileInfo:i,tilemapCache:n}=this.layer,a=w(i,n)[t].level;this.geometry.coordinates.forEach(l=>l.tile=i.tileAt(a,l.x,l.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(t=>!t.elevationTile)}clearElevationTiles(){for(const t of this.geometry.coordinates)t.elevationTile!==this.outsideExtentTile&&(t.elevationTile=null)}populateElevationTiles(t){for(const i of this.geometry.coordinates)!i.elevationTile&&i.tile?.id&&(i.elevationTile=t[i.tile.id])}remapTiles(t){for(const i of this.geometry.coordinates){const n=i.tile?.id;i.tile=n?t[n]:null}}getTilesToFetch(){return se(this.geometry.coordinates.filter(({tile:t,elevationTile:i})=>t?.id&&!i),(t,i)=>t.tile?.id===i.tile?.id).map(({tile:t})=>t)}forEachTileToFetch(t){for(const i of this.geometry.coordinates)i.tile&&!i.elevationTile&&t(i.tile,()=>i.tile=null)}};class ye extends H{constructor(t,i,n,a){super(t,n),this.maskExtents=a,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=i.clone().intersection(t.fullExtent)}selectTilesAtLOD(t,i){const n=this._maximumLodForRequests(i),a=Math.min(n,t);a<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(a)}_maximumLodForRequests(t){const{tileInfo:i,tilemapCache:n}=this.layer,a=w(i,n);if(!t)return a.length-1;const l=this.extent;if(l==null)return-1;for(let s=a.length-1;s>=0;s--){const o=a[s],r=o.resolution*i.size[0],c=o.resolution*i.size[1];if(Math.ceil(l.width/r)*Math.ceil(l.height/c)<=t)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(t){for(const i of this._candidateTiles){const n=i.id&&t[i.id];n&&(this._fetchedCandidates.add(i),this.elevationTiles.push(n))}}remapTiles(t){this._candidateTiles=P(this._candidateTiles.map(i=>t[i.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(t,i){const n=this._candidateTiles;this._candidateTiles=[],n.forEach(a=>{if(this._fetchedCandidates.has(a))return void i?.(a);let l=!1;t(a,()=>l=!0),l?i?.(a):this._candidateTiles.push(a)}),this._candidateTiles=P(this._candidateTiles,i)}_selectCandidateTilesCoveringExtentAt(t){this._candidateTiles.length=0;const i=this.extent;if(i==null)return;const{tileInfo:n,tilemapCache:a}=this.layer,l=w(n,a)[t],s=n.tileAt(l.level,i.xmin,i.ymin),o=s.extent,r=l.resolution*n.size[0],c=l.resolution*n.size[1],f=Math.ceil((i.xmax-o[0])/r),u=Math.ceil((i.ymax-o[1])/c);for(let h=0;h<u;h++)for(let y=0;y<f;y++){const v=new V(s.level,s.row-h,s.col+y);n.updateTileInfo(v),this._tileIsMasked(v)||this._candidateTiles.push(v)}}_tileIsMasked(t){return this.maskExtents?.some(i=>Z(i,t.extent))??!1}}function C(e){return e?.tileInfo!=null}function w(e,t){const i=e.lods;if(C(t)){const{effectiveMinLOD:n,effectiveMaxLOD:a}=t;return i.filter(l=>l.level>=n&&l.level<=a)}return i}function P(e,t){const i={},n=[];for(const l of e){const s=l.id;s&&!i[s]?(i[s]=l,n.push(l)):t?.(l)}const a=n.sort((l,s)=>l.level-s.level);return a.filter((l,s)=>{for(let o=0;o<s;o++){const r=a[o].extent;if(r&&Z(r,l.extent))return t?.(l),!1}return!0})}let ve=class{constructor(t,i){this.data=t,this.safeWidth=.99999999*(t.width-1),this.dx=(t.width-1)/(i[2]-i[0]),this.dy=(t.width-1)/(i[3]-i[1]),this.x0=i[0],this.y1=i[3]}};class K{constructor(t,i=null){if(this.key=t,i!=null){const n=t.extent;this._samplerData=new ve(i,n)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(t,i){if(this._samplerData==null)return;const{safeWidth:n,data:a,dx:l,dy:s,y1:o,x0:r}=this._samplerData,{width:c,values:f,noDataValue:u}=a,h=W(s*(o-i),0,n),y=W(l*(t-r),0,n),v=Math.floor(h),F=Math.floor(y),_=v*c+F,M=_+c,A=f[_],q=f[M],z=f[_+1],L=f[M+1];if(A!==u&&q!==u&&z!==u&&L!==u){const O=y-F,j=A+(z-A)*O;return j+(q+(L-q)*O-j)*(h-v)}}}function W(e,t,i){return e<t?t:e>i?i:e}let I=class extends oe{queryElevation(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case"point":return ge(e,t,this);case"polyline":return xe(e,t,this);case"multipoint":return Te(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;const i=e.spatialReference;if(i.equals(t))return e;const n=re(e,t);return n||G.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${i.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),n}};function ge(e,t,i){return e.hasZ=!0,e.z=i.elevationAt(t.x,t.y),e}function xe(e,t,i){m.spatialReference=t.spatialReference;const n=e.hasM&&!e.hasZ;for(let a=0;a<e.paths.length;a++){const l=e.paths[a],s=t.paths[a];for(let o=0;o<l.length;o++){const r=l[o],c=s[o];m.x=c[0],m.y=c[1],n&&(r[3]=r[2]),r[2]=i.elevationAt(m.x,m.y)}}return e.hasZ=!0,e}function Te(e,t,i){m.spatialReference=t.spatialReference;const n=e.hasM&&!e.hasZ;for(let a=0;a<e.points.length;a++){const l=e.points[a],s=t.points[a];m.x=s[0],m.y=s[1],n&&(l[3]=l[2]),l[2]=i.elevationAt(m.x,m.y)}return e.hasZ=!0,e}I=p([$("esri.layers.support.ElevationSampler")],I);const m=new ce;let x=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(e){const t=e.noDataValue,i="tiles"in e?e.tiles.map(a=>new g({tile:a,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:i});const n=i[0];if(n){this.extent=n.extent.clone();const{min:a,max:l}=n.demResolution;this.demResolution={min:a,max:l};for(let s=1;s<i.length;s++){const o=i[s];this.extent.union(o.extent),this.demResolution.min=Math.min(this.demResolution.min,o.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,o.demResolution.max)}}else{const a="tileInfo"in e?e.tileInfo:null;this.extent=N(fe(),a?.spatialReference??ue.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let i;for(const n of this.samplers)if(n.containsAt(e,t)&&(i=n.elevationAt(e,t),i!==n.noDataValue))return i;return i??(G.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};p([T({constructOnly:!0})],x.prototype,"noDataValue",void 0),p([T({constructOnly:!0})],x.prototype,"samplers",void 0),x=p([$("esri.layers.support.TileElevationSampler")],x);let g=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);const t=e.tile.key.extent;this.extent=N(t,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;const i=D(e.tileInfo.spatialReference),n=e.tileInfo.lodAt(e.tile.key.level).resolution*i;this.demResolution={min:n,max:n}}contains(e){const t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return he(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};p([T({constructOnly:!0})],g.prototype,"tile",void 0),p([T({constructOnly:!0})],g.prototype,"noDataValue",void 0),p([T({constructOnly:!0})],g.prototype,"tileInfo",void 0),g=p([$("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],g);async function Me(e,t,i){if(e=i?.ignoreInvisibleLayers?e.filter(r=>r.visible):e.slice(),!e.length)throw new d(S,"Elevation queries require at least one elevation layer to fetch tiles from");const n=R.fromGeometry(t),a={...k,...i,returnSampleInfo:!0},l=e.pop(),s=await Q(l,n,a),o=await te(e,s,a);return o.geometry=o.geometry.export(),i?.returnSampleInfo||delete o.sampleInfo,o}async function Q(e,t,i){if(!e)throw new d(S,"Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof R)&&t.type!=="point"&&t.type!=="multipoint"&&t.type!=="polyline")throw new d("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const n={...k,...i},a=new de(e,t.spatialReference,n),l=n.signal;return await e.load({signal:l}),await Ie(a,t,l),await ie(a,l),await E(a,l),Ve(a),$e(a,l)}async function ze(e,t,i){if(e=Array.isArray(e)?e:[e],(e=i?.ignoreInvisibleLayers?e.filter(l=>l.visible):e.slice()).length===0)throw new d(S,"Elevation queries require at least one elevation layer to fetch tiles from");if(!t||t.type!=="extent")throw new d("elevation-query:invalid-extent","Invalid or undefined extent");const n={...k,...i,returnSampleInfo:!0},a=X(e[e.length-1],t,n);return e.length===1?a:ee(e,t,await a,n)}async function X(e,t,i,n){const a=i.signal;await e.load({signal:a});const l=t.spatialReference,s=e.tileInfo.spatialReference;l.equals(s)||(await U([{source:l,dest:s}],{signal:a}),t=B(t,s));const o=new ye(e,t,i,n);await ie(o,a),await E(o,a);const r=o.elevationTiles,c=o.layer.tileInfo,f=o.parameters.noDataValue;return new x({noDataValue:f,tiles:r,tileInfo:c})}async function ee(e,t,i,n){if(e.pop(),!e.length)return i;const a=i.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>me(r.extent)),l=await X(e[e.length-1],t,n,a);if(l.samplers.length===0)return i;const s=i.samplers.concat(l.samplers),o=n.noDataValue;return ee(e,t,new x({samplers:s,noDataValue:o}),n)}async function te(e,t,i){const n=t.geometry.coordinates,a=t.sampleInfo;J(a);const l=new Array,s=new Array;for(let u=0;u<n.length;u++)a[u].demResolution<0&&e.length&&(l.push(n[u]),s.push(u));const o=e.pop();if(o==null||l.length===0)return t;const r=t.geometry.clone(l),c=await Q(o,r,i),f=c.sampleInfo;if(!f)throw new Error("no sampleInfo");return s.forEach((u,h)=>{n[u].z=c.geometry.coordinates[h].z,a[u].demResolution=f[h].demResolution,a[u].source=f[h].source}),te(e,t,i)}async function ie(e,t){e.type==="geometry"&&De(e);const i=e.parameters.demResolution;if(typeof i=="number")_e(e,i);else if(i==="finest-contiguous")await we(e,t);else{if(i!=="auto")throw new d("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${i}', expected a number, "finest-contiguous" or "auto"`);await Re(e,t)}}async function we(e,t){const{tileInfo:i,tilemapCache:n}=e.layer,a=le(i,n,e.parameters.minDemResolution);await ne(e,a,t)}async function ne(e,t,i){const n=e.layer;if(e.selectTilesAtLOD(t),t<0)return;const a=n.tilemapCache,l=e.getTilesToFetch();try{if(a&&!C(a))await b(Promise.all(l.map(s=>a.fetchAvailability(s.level,s.row,s.col,{signal:i}))),i);else if(await E(e,i),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new d("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){Y(s),await ne(e,t-1,i)}}async function Re(e,t){Ae(e),qe(e);const i=e.layer.tilemapCache;if(!i||C(i))return ae(e,t);const n=e.getTilesToFetch(),a={},l=n.map(async s=>{const o=new V(0,0,0),r=await pe(i.fetchAvailabilityUpsample(s.level,s.row,s.col,o,{signal:t}));r.ok!==!1?s.id!=null&&(a[s.id]=o):Y(r.error)});await b(Promise.all(l),t),e.remapTiles(a)}async function ae(e,t){const i=e.layer.tileInfo;await E(e,t);let n=!1;e.forEachTileToFetch((a,l)=>{i.upsampleTile(a)?n=!0:l()}),n&&await ae(e,t)}function le(e,t,i=0){const n=w(e,t);let a=n.length-1;if(i>0){const l=i/D(e.spatialReference),s=n.findIndex(o=>o.resolution<l);s===0?a=0:s>0&&(a=s-1)}return a}const k={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function Ie(e,t,i){let n;const a=e.layer.tileInfo.spatialReference;if(t instanceof R?n=await t.project(a,i):(await U([{source:t.spatialReference,dest:a}],{signal:i}),n=B(t,a)),!n)throw new d("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${a.wkid}'`);e.geometry=R.fromGeometry(n)}function De(e){if(e.layer.fullExtent==null)return;const t=new K(new V(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;const i=e.layer.fullExtent;e.geometry.coordinates.forEach(n=>{const a=n.x,l=n.y;(a<i.xmin||a>i.xmax||l<i.ymin||l>i.ymax)&&(n.elevationTile=t)})}function Ee(e,t){const{tileInfo:i,tilemapCache:n}=e.layer,a=t/D(i.spatialReference),l=w(i,n);let s=l[0],o=0;for(let r=1;r<l.length;r++){const c=l[r];Math.abs(c.resolution-a)<Math.abs(s.resolution-a)&&(s=c,o=r)}return o}function _e(e,t){const i=Ee(e,t);e.selectTilesAtLOD(i)}function Ae(e){const{tileInfo:t,tilemapCache:i}=e.layer,n=le(t,i,e.parameters.minDemResolution);e.selectTilesAtLOD(n,e.parameters.maximumAutoTileRequests)}async function E(e,t){const i=e.getTilesToFetch(),n={},a=e.parameters.cache,l=e.parameters.noDataValue,s={noDataValue:l,signal:t},o=i.map(async r=>{if(r.id==null)return;const c=`${e.layer.uid}:${r.id}:${l}`,f=a?.get(c),u=f??await e.layer.fetchTile(r.level,r.row,r.col,s);a?.put(c,u),n[r.id]=new K(r,u)});await b(Promise.allSettled(o),t),e.populateElevationTiles(n)}function qe(e){const t=e.layer.tileInfo;let i=0;const n={},a=o=>{o.id!=null&&(o.id in n?n[o.id]++:(n[o.id]=1,i++))},l=o=>{if(o.id==null)return;const r=n[o.id];r===1?(delete n[o.id],i--):n[o.id]=r-1};e.forEachTileToFetch(a,l);let s=!0;for(;s&&(s=!1,e.forEachTileToFetch(o=>{i<=e.parameters.maximumAutoTileRequests||(l(o),t.upsampleTile(o)&&(s=!0),a(o))},l),s););}function Ve(e){e.geometry.coordinates.forEach(t=>{const i=t.elevationTile;let n=e.parameters.noDataValue;if(i){const a=i.sample(t.x,t.y);a==null?t.elevationTile=null:n=a}t.z=n})}async function $e(e,t){const i=await e.geometry.project(e.outSpatialReference,t);J(i);const n={geometry:i.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(n.sampleInfo=be(e)),e.geometry.coordinates.forEach(a=>{a.tile=null,a.elevationTile=null}),n}function be(e){const t=e.layer.tileInfo,i=D(t.spatialReference);return e.geometry.coordinates.map(n=>{let a=-1;return n.elevationTile&&n.elevationTile!==e.outsideExtentTile&&(a=t.lodAt(n.elevationTile.key.level).resolution*i),{demResolution:a,source:a===-1?void 0:e.layer}})}const S="elevation-query:invalid-layer";export{S as InvalidLayerError,ze as createSampler,k as defaultOptions,le as getFinestLodIndex,Q as query,Me as queryAll};
