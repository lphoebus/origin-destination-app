import{gk as C,gl as q}from"./index-Bkom2Sdc.js";import{c as z,m as p,b as U,a as _,n as Y,P as $,$ as ct,x as et,w as it,h as st,R as ht}from"./Point2D-DVg-Qhcx.js";import{I as rt,Q as V,R as lt,S as b,U as w,a0 as R,$ as E,aP as j,f as _t,aQ as M,ar as k,aR as pt,X as dt,aS as gt,N as xt,aO as yt,u as Pt,aT as Q,a2 as F,aq as ut}from"./ProjectionTransformation-Bvt2x7E-.js";import{Envelope2D as N}from"./Envelope2D-7paLNnHT.js";import{x as nt}from"./Transformation2D-CNf0ySKF.js";import{M as St,q as ft,v as ot}from"./Distance2DCalculator-CXhBP-8I-CkbBs3iU.js";import{s as Gt}from"./SimpleGeometryCursor-B92kdZ15.js";import{OperatorGeodeticDensifyCursor as Dt}from"./OperatorGeodeticDensifyByLength-BprbSDSO.js";class vt{getOperatorType(){return 10317}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,i,s,n,o){return new Dt(e,t,4,i,s,n,o)}execute(e,t,i,s,n,o){const a=new Gt([e]),m=this.executeMany(a,t,i,s,n,o).next();return m||z("null output"),m}}function Tt(){return new N}class bt{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(e,t,i){this.m_peR1=new b,this.m_peR2=new b,this.m_peR3=new b,e!==void 0?this.reset(e,t,i):this.reset(1,0,1)}reset(e,t,i){this.m_a=e,this.m_e2=t,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(e,t,i,s){const n=this.m_peR1,o=this.m_peR2,a=this.m_peR3;w.geodeticDistance(this.m_a,this.m_e2,e*this.m_unitToRad,t*this.m_unitToRad,i*this.m_unitToRad,s*this.m_unitToRad,a,n,o,0);const m=Math.cos(n.val),r=Math.cos(o.val+3.141592653589793),u=t*this.m_unitToRad,c=F.phiToEta(this.m_e2,u),h=Math.sin(n.val)*Math.cos(c);let g=t;if(m*r<0){const D=m<0?-1:1,f=Math.acos(Math.abs(h))*D;g=F.etaToPhi(this.m_e2,f)/this.m_unitToRad}let d=ht((i-e)*this.m_unitToRad,2*Math.PI);Math.abs(d)>Math.PI&&(d=d>0?d-2*Math.PI:d+2*Math.PI),d/=this.m_unitToRad,i=e+d;const l=Tt();return l.xmin=Math.min(e,i),l.xmax=Math.max(e,i),l.ymin=Math.min(t,s),l.ymin=Math.min(l.ymin,g),l.ymax=Math.max(t,s),l.ymax=Math.max(l.ymax,g),l}minDistanceGeodesic(e,t){const i=at(e),s=at(t);if(i&&s)return this.lowerDistanceGeodetic_(e.xmin,e.ymin,t.xmin,t.ymin);const n=this.normalizeGeodesic_(t,e);return wt(e,n)?e.ymin>=n.ymax?this.minDistanceGeodesicUpDown_(e,n):n.ymin>=e.ymax?this.minDistanceGeodesicUpDown_(n,e):e.xmin>n.xmax?this.minDistanceGeodesicLeftRight_(n,e):this.minDistanceGeodesicLeftRight_(e,n):0}normalizeGeodesic_(e,t){const i=e.clone(),s=e.clone();let n=W(i,t);if(n===0)return i;for(;s.xmax>t.xmin;){s.xmin-=this.m_u360,s.xmax-=this.m_u360;const o=W(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}for(s.assign(e);s.xmin<t.xmax;){s.xmin+=this.m_u360,s.xmax+=this.m_u360;const o=W(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}return i}lowerDistanceGeodetic_(e,t,i,s){const n=this.m_peR1;{const o=this.m_b*this.m_b/this.m_a,a=F.phiToPhig(this.m_e2,this.m_unitToRad*t),m=F.phiToPhig(this.m_e2,this.m_unitToRad*s);w.geodeticDistance(o,0,this.m_unitToRad*e,a,this.m_unitToRad*i,m,n,null,null,0)}return n.val}minDistanceGeodesicUpDown_(e,t){if(t.xmin<=e.xmin?t.xmax>=e.xmin:e.xmax>=t.xmin)return this.lowerDistanceGeodetic_(0,e.ymin,0,t.ymax);if(t.xmin>e.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);return Math.min(i,s)}{const i=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);return Math.min(i,s)}}minDistanceGeodesicLeftRight_(e,t){let i=Math.abs(e.xmax-t.xmin);for(;i>this.m_u180;)i-=this.m_u360;let s=Math.abs(e.xmin-t.xmax);for(;s>this.m_u180;)s-=this.m_u360;return Math.abs(i)<=Math.abs(s)?this.minDistanceGeodesicLeftRightNormalized_(e,t):this.minDistanceGeodesicLeftRightNormalized_(t,e)}minDistanceGeodesicLeftRightNormalized_(e,t){let i,s;return i=this.lowerDistanceGeodetic_(e.xmax,e.ymin,t.xmin,t.ymin),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymin,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymin,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),s=this.lowerDistanceGeodetic_(e.xmax,e.ymax,t.xmin,t.ymax),i=Math.min(i,s),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymax,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymax,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),i}lowerDistanceGeodeticSegMeridional_(e,t,i,s,n,o){let a=this.lowerDistanceGeodeticPtMeridional_(e,t,s,n,o);const m=this.lowerDistanceGeodeticPtMeridional_(e,i,s,n,o);let r=this.lowerDistanceGeodeticPtMeridional_(s,n,e,t,i);const u=this.lowerDistanceGeodeticPtMeridional_(s,o,e,t,i);return a=Math.min(a,m),r=Math.min(r,u),Math.min(a,r)}lowerDistanceGeodeticPtMeridional_(e,t,i,s,n){const o=this.m_b*this.m_b/this.m_a,a=F.phiToPhig(this.m_e2,this.m_unitToRad*t),m=F.phiToPhig(this.m_e2,this.m_unitToRad*s),r=F.phiToPhig(this.m_e2,this.m_unitToRad*n),u=this.m_peR1,c=this.m_peR2;w.geodeticDistance(o,0,this.m_unitToRad*i,m,this.m_unitToRad*e,a,u,null,null,0),w.geodeticDistance(o,0,this.m_unitToRad*i,r,this.m_unitToRad*e,a,c,null,null,0);const h=R(1,0,new p(this.m_unitToRad*e,a)),g=R(1,0,new p(this.m_unitToRad*i,m)),d=R(1,0,new p(this.m_unitToRad*i,r));let l=new E;l.setCrossProductVector(g,d);const D=g.dotProduct(d);if(l.length()<1568e-13)return D>=0?Math.min(u.val,c.val):0;l=l.getUnitVector();let f=new E;if(f.setCrossProductVector(l,h),f.length()<1568e-13)return Math.min(u.val,c.val)-1e-5*o;f=f.getUnitVector();let x=h.sub(l.mul(h.dotProduct(l)));{const S=new E;S.setCrossProductVector(g,x);const v=new E;v.setCrossProductVector(x,d);let P=l.dotProduct(S)>0&&l.dotProduct(v)>0;if(P||(x.negateThis(),S.setCrossProductVector(g,x),v.setCrossProductVector(x,d),P=l.dotProduct(S)>0&&l.dotProduct(v)>0),P){x=x.getUnitVector();const O=ut(1,0,x),X=this.m_peR3;w.geodeticDistance(o,0,this.m_unitToRad*e,a,O.x,O.y,X,null,null,0);const B=Math.min(u.val,c.val);return Math.min(B,X.val)}}return Math.min(u.val,c.val)}}function at(y){return y.xmin===y.xmax&&y.ymin===y.ymax}function wt(y,e){return e.xmax<y.xmin||e.xmin>y.xmax||e.ymax<y.ymin||e.ymin>y.ymax}function W(y,e){let t,i=0;return t=y.xmin-e.xmax,t>i&&(i=t),t=e.xmin-y.xmax,t>i&&(i=t),i}class Mt{}function mt(y){return{outPoint:y===void 0?new p:y.clone()}}function L(y,e){y.outPoint.assign(e.outPoint)}function T(){return new N}class Rt{constructor(e,t,i,s,n=0,o=4){this.m_ptDistFrom=new p,this.m_segStartPt=new p,this.m_segEndPt=new p,this.m_geodeticLength=new b,this.m_az12=new b,this.m_minGeodeticDist=new b,this.m_segStartPt3d=new E,this.m_segEndPt3d=new E,this.m_sr=s,this.m_distCurveType=n,this.m_segCurveType=o,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();const a=rt();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,i)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(R(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(R(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return e=>{let t;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const s=C(i,new b,!1),n=C(i,new b,!1);w.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*e,this.m_az12.val,s,n,this.m_segCurveType),t=new p(s.val,n.val);break}catch(s){i.error=s,i.hasError=!0}finally{q(i)}}case 2:{const i=E.lerp(this.m_segStartPt3d,this.m_segEndPt3d,e);t=ut(this.m_a,this.m_eSquared,i);break}case 4:t=p.lerp(this.m_segStartPt,this.m_segEndPt,e),this.m_bIsPannablePcs&&(M(this.m_sr,0,[t],1),t.mulThis(this.m_rpu));break;default:z("Invalid curve type")}return w.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,t.x,t.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:w.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=p.distance(this.m_segStartPt,this.m_segEndPt);break;default:z("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function J(){return new Mt}class Xt{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(e,t,i,s,n){this.m_boxGeomA=T(),this.m_boxGeomB=T(),this.m_envGeomA=new N,this.m_envGeomB=new N,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new nt,this.m_scaleToDegrees=new nt,this.m_inputSR=e,this.m_distCurveType=t,this.m_progressTracker=i,this.m_maxDistance=s,this.m_maxDeviation=n,this.m_inputGCS=e.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const o=rt();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new bt(this.m_a,this.m_eSquared,1),this.m_distCurveType===4&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=this.m_inputSR.getCoordinateSystemType()===2&&this.m_inputSR.isPannable()}progress(e=!1){}calculate(e,t,i,s){const n=mt(),o=mt();if(e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(e,t,n,o))return i&&L(i,n),s&&L(s,o),0;const a=this.prepareGeometry(e);if(a.isEmpty())return Number.NaN;const m=this.prepareGeometry(t);if(m.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(a,m);const r=this._ExecuteBruteForce(a,m,n,o);return r>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(n),L(i,n)),s&&(this.prepareOutput(o),L(s,o)),r)}createDistanceFunctor(e,t,i){const s=new Rt(e,t,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||this.m_inputSR.getCoordinateSystemType()===1||s.setSegmentCurveType(2),s}_NormalizeAndProject(e){if(this.m_inputSR.isPannable()&&(e=new V().foldInto360Range(e,this.m_inputSR)),this.m_inputSR.getCoordinateSystemType()===2){const t=lt(this.m_inputSR,this.m_inputGCS,null);e=new V().execute(e,t,this.m_progressTracker)}return e}_ExecuteBruteForce(e,t,i,s){switch(e.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointGeometry(e,t,i,s);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(e,t,i,s);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(e,t,i,s);default:U("")}}calculateDistanceGeodeticPointGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointPoint(e,t,i,s);case _.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,i,s);case _.enumPolyline:case _.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(e,t,i,s);default:U("")}}calculateDistanceGeodeticPointPoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=e.getXY();o.scale(this.m_rpu);const a=t.getXY();a.scale(this.m_rpu),i.outPoint.assign(o),s.outPoint.assign(a);const m=C(n,new b,!1);return w.geodeticDistance(this.m_a,this.m_eSquared,o.x,o.y,a.x,a.y,m,null,null,this.m_distCurveType),m.val}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticPointMultipoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(e,t);const o=this.estimateMinimumDistance(i,s);let a=o<this.m_maxDistance?o:this.m_maxDistance;const m=e.getXY();m.scale(this.m_rpu),i.outPoint.assign(m);const r=R(this.m_a,this.m_eSquared,m),u=new p,c=t.getImpl(),h=C(n,new b,!1),g=c.getPointCount();for(let d=0;d<g;++d){c.queryXY(d,u),u.scale(this.m_rpu);const l=R(this.m_a,this.m_eSquared,u);if(!(E.distance(r,l)>a)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>a)&&(w.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,u.x,u.y,h,null,null,this.m_distCurveType),h.val<a&&(a=h.val,s.outPoint=u,a===0)))return a}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticPointMultipath(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=new p,a=new p;o.assign(e.getXY()),a.assign(e.getXY()),i.outPoint.assign(a.mul(this.m_rpu)),this.m_bIsPannablePcs&&j(this.m_inputSR,[o],1,!1),this.computeEnvelopesAndBoxes(e,t);const m=this.estimateMinimumDistance(i,s);let r=m<this.m_maxDistance?m:this.m_maxDistance;const u=t.getImpl(),c=new p(0,0),h=new p(0,0),g=[1],d=this.canUseSpatialTree(e,t),l=J();d&&this.buildSpatialTree(l,t);const D=T();D.setCoords({xmin:a.x,ymin:a.y,xmax:a.x,ymax:a.y});const f=C(n,this.createDistanceFunctor(a,c,h),!1),x=u.querySegmentIterator();if(x.stripAttributes(),d)Y(0);else for(;x.nextPath();)for(;x.hasNextSegment();){const S=x.nextSegment(),v=this.findOrComputeBoxSegment(x.getStartPointIndex(),S,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(D,v)>r)continue;const P=this.calculateDistanceGeodeticPointSegment(o,a,S,g,f);if(P.second<r&&(this.updateOutputSegment(s,S,P.first),r=P.second,r===0))return 0}return r===this.m_maxDistance?Number.POSITIVE_INFINITY:r}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipointGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,s,i);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(e,t,i,s);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(e,t,i,s);default:U("")}}calculateDistanceGeodeticMultipointMultipoint(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=C(n,new b,!1);this.computeEnvelopesAndBoxes(e,t);const a=this.estimateMinimumDistance(i,s);let m=a<this.m_maxDistance?a:this.m_maxDistance;const r=new p,u=new p,c=e.getImpl(),h=t.getImpl(),g=T(),d=c.getPointCount(),l=h.getPointCount();for(let D=0;D<d;++D){if(r.assign(c.getXY(D)),g.setCoords({xmin:r.x,ymin:r.y,xmax:r.x,ymax:r.y}),this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>m)continue;r.scale(this.m_rpu);const f=R(this.m_a,this.m_eSquared,r);for(let x=0;x<l;++x){u.assign(h.getXY(x)),u.scale(this.m_rpu);const S=R(this.m_a,this.m_eSquared,u);if(!(E.distance(f,S)>=m)&&(w.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,u.x,u.y,o,null,null,this.m_distCurveType),o.val<m&&(i.outPoint.assign(r),s.outPoint.assign(u),m=o.val,m===0)))return m}}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipointMultipath(e,t,i,s){const n={stack:[],error:void 0,hasError:!1};try{const o=t.getImpl().querySegmentIterator();o.stripAttributes(),this.computeEnvelopesAndBoxes(e,t);const a=this.estimateMinimumDistance(i,s);let m=a<this.m_maxDistance?a:this.m_maxDistance;const r=new p,u=new p(0,0),c=new p(0,0),h=new p(0,0),g=[0],d=T(),l=C(n,this.createDistanceFunctor(u,c,h),!1),D=J(),f=this.canUseSpatialTree(e,t);f&&this.buildSpatialTree(D,t);const x=e.getPointCount();for(let S=0;S<x;++S)if(r.assign(e.getXY(S)),u.assign(e.getXY(S)),this.m_bIsPannablePcs&&j(this.m_inputSR,[r],1,!1),d.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),!(this.m_envHelper.minDistanceGeodesic(d,this.m_boxGeomB)>m))if(l.setPointDistFrom(u),f)Y(0);else{for(;o.nextPath();)for(;o.hasNextSegment();){const v=o.nextSegment();if(this.m_envHelper.minDistanceGeodesic(d,this.findOrComputeBoxSegment(o.getStartPointIndex(),v,this.m_segmentBoxesB))>m)continue;const P=this.calculateDistanceGeodeticPointSegment(r,u,v,g,l);if(P.second<m&&(i.outPoint.assign(u.mul(this.m_rpu)),this.updateOutputSegment(s,v,P.first),m=P.second,m===0))return 0}o.resetToFirstPath()}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(o){n.error=o,n.hasError=!0}finally{q(n)}}calculateDistanceGeodeticMultipathGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointMultipath(t,e,s,i);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(t,e,s,i);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(e,t,i,s);default:U("")}}calculateDistanceGeodeticMultipathMultipath(e,t,i,s){const n=[e],o=[t],a=this.swapGeometries(n,o),m=n[0],r=o[0];this.computeEnvelopesAndBoxes(n[0],o[0]);const u=this.estimateMinimumDistance(i,s),c=this.calculateDistanceGeodeticMultipathMultipath_(m,r,i,s,u);return a&&(s.outPoint=$(i.outPoint,i.outPoint=s.outPoint)),c}calculateDistanceGeodeticMultipathMultipath_(e,t,i,s,n=Number.MAX_VALUE){const o={stack:[],error:void 0,hasError:!1};try{let a=n;const m=new p(0,0),r=new p,u=new p(0,0),c=new p,h=new p(0,0),g=new p,d=new p,l=new p,D=[new p],f=[0],x=[0],S=T(),v=T(),P=C(o,this.createDistanceFunctor(h,m,u),!1),O=J(),X=this.canUseSpatialTree(e,t);X&&this.buildSpatialTree(O,t);const B=t.querySegmentIterator();B.stripAttributes();const K=new _t,Z=St(e);for(let H=0;H<Z.length;++H){const tt=Z[H];e.getSegmentBuffer(tt,K,!0);const I=K.get();if(S.assign(this.findOrComputeBoxSegment(tt,I,this.m_segmentBoxesA)),X)Y(0);else{if(h.assign(I.getStartXY()),g.assign(I.getStartXY()),d.assign(I.getEndXY()),l.assign(I.getEndXY()),this.m_bIsPannablePcs&&(M(this.m_inputSR,0,[g],1),M(this.m_inputSR,0,[l],1)),this.m_envHelper.minDistanceGeodesic(S,this.m_boxGeomB)>a)continue;for(;B.nextPath();){for(;B.hasNextSegment();){const A=B.nextSegment();if(m.assign(A.getStartXY()),r.assign(A.getStartXY()),u.assign(A.getEndXY()),c.assign(A.getEndXY()),I.intersect(A,D,f,x,this.m_tolerance))return this.updateOutputSegment(i,I,f[0]),this.updateOutputSegment(s,A,x[0]),0;if(this.m_bIsPannablePcs&&(M(this.m_inputSR,0,[r],1),M(this.m_inputSR,0,[c],1)),v.assign(this.findOrComputeBoxPoint(B.getStartPointIndex(),r,c,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(S,v)>a)continue;P.setSegmentEndPoints(m,u),P.setPointDistFrom(g);let G=k(P.makeFunctor(),0,1,1e-10);if(G.second<a&&(i.outPoint.assign(g.mul(this.m_rpu)),this.updateOutputSegment(s,A,G.first),a=G.second,a===0)||(P.setPointDistFrom(l),G=k(P.makeFunctor(),0,1,1e-10),G.second<a&&(i.outPoint.assign(l.mul(this.m_rpu)),this.updateOutputSegment(s,A,G.first),a=G.second,a===0))||(P.setSegmentEndPoints(h,d),P.setPointDistFrom(r),G=k(P.makeFunctor(),0,1,1e-10),G.second<a&&(this.updateOutputSegment(i,I,G.first),s.outPoint.assign(r.mul(this.m_rpu)),a=G.second,a===0))||(P.setPointDistFrom(c),G=k(P.makeFunctor(),0,1,1e-10),G.second<a&&(this.updateOutputSegment(i,I,G.first),s.outPoint.assign(c.mul(this.m_rpu)),a=G.second,a===0)))break}if(a===0)return 0}B.resetToFirstPath()}}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(a){o.error=a,o.hasError=!0}finally{q(o)}}calculateDistanceGeodeticPointSegment(e,t,i,s,n){const o=i.getStartXY(),a=i.getEndXY();return i.intersectPoint(e,s,this.m_tolerance)?ct(s[0],0):(n.setPointDistFrom(t),n.setSegmentEndPoints(o,a),k(n.makeFunctor(),0,1,1e-10))}prepareGeometry(e){let t=e.clone();const i=e.getGeometryType();if(i===_.enumPoint||i===_.enumMultiPoint)return this._NormalizeAndProject(t);if(i===_.enumEnvelope&&(t=this.envelopeToPolygon(t)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(t,4);if(this.m_inputSR.getCoordinateSystemType()===2){if(t=pt(t,this.m_inputSR,0,null),t.isEmpty())return t;t=new vt().execute(t,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const o=this.m_inputSR.getSRToGCSTransform();return new V().execute(t,o,this.m_progressTracker)}const s=new N;t.queryLooseEnvelope(s);const n=this.m_inputSR.getPannableExtent();if(s.ymin<n.ymin||s.ymax>n.ymax){const o=new N(s.xmin-1,n.ymin,s.xmax+1,n.ymax);if(t=new dt().execute(t,o,this.m_inputSR,this.m_progressTracker),t.isEmpty())return t}return s.width()>2*n.width()&&(t=gt(t,-2*n.width(),2*n.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker)),t}prepareGeometryPannable(e,t){const i=new N;e.queryEnvelope(i);const s=this.m_inputSR.getPannableExtent();if(s.containsEnvelope(i))return e;const n=new et;s.queryIntervalX(n);const o=new et;return i.queryIntervalX(o),e=n.contains(o)?xt(e,this.m_inputSR):new V().foldInto360RangeGeodetic(e,this.m_inputSR,t)}prepareOutput(e){e.outPoint.scale(1/this.m_rpu),this.m_inputSR.getCoordinateSystemType()===2&&j(this.m_inputSR,[e.outPoint],1,!1)}updateOutputSegment(e,t,i){t.queryCoord2D(i,e.outPoint),this.m_bIsPannablePcs&&M(this.m_inputSR,0,[e.outPoint],1),e.outPoint.mulThis(this.m_rpu)}computeTolerance(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB);const i=new N(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),yt(null,i)}envelopeToPolygon(e){const t=new Pt;return t.addEnvelope(e,!1),t}computeEnvelopesAndBoxes(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(e,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(t,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(e,t,i){switch(e.getGeometryType()){case _.enumPoint:return this.computeBoxPoint(e,t);case _.enumMultiPoint:return this.computeBoxMultiPoint(e,t);case _.enumPolyline:case _.enumPolygon:return this.computeBoxMultiPath(e,t,i);default:z("Invalid geometry type")}}computeBoxPoint(e,t){const i=e.getXY();t.length=0,t.push(i.mul(this.m_rpu));const s=T();return s.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),s}computeBoxMultiPoint(e,t){let i=!0;for(let n=0;n<e.getPointCount();++n){const o=e.getXY(n);if(i){t.length=0;for(let a=0;a<4;++a)t.push(o.clone());i=!1}o.x<t[0].x&&t[0].assign(o),o.y>t[1].y&&t[1].assign(o),o.x>t[2].x&&t[2].assign(o),o.y<t[3].y&&t[3].assign(o)}for(let n=0;n<t.length;++n)t[n].mulThis(this.m_rpu);const s=T();return e.queryEnvelope(s),s}computeBoxMultiPath(e,t,i){let s=!0;const n=T();n.setEmpty();const o=e.querySegmentIterator();for(o.stripAttributes();o.nextPath();)for(;o.hasNextSegment();){const a=o.nextSegment(),m=a.getStartXY(),r=a.getEndXY();if(this.m_bIsPannablePcs&&(M(this.m_inputSR,0,[m],1),M(this.m_inputSR,0,[r],1)),s){for(let c=0;c<4;++c)t.push(m.clone());s=!1}m.x<t[0].x&&t[0].assign(m),m.y>t[1].y&&t[1].assign(m),m.x>t[2].x&&t[2].assign(m),m.y<t[3].y&&t[3].assign(m),r.x<t[0].x&&t[0].assign(r),r.y>t[1].y&&t[1].assign(r),r.x>t[2].x&&t[2].assign(r),r.y<t[3].y&&t[3].assign(r);const u=this.findOrComputeBoxPoint(o.getStartPointIndex(),m,r,i);n.mergeEnvelope2D(u)}for(let a=0;a<t.length;++a)t[a].mulThis(this.m_rpu);return n}findOrComputeBoxSegment(e,t,i){if(!i.has(e)){let s=T();if(t.queryEnvelope(s),this.m_bIsPannablePcs){const n=p.construct(s.xmin,s.ymin),o=p.construct(s.xmax,s.ymax);M(this.m_inputSR,0,[n],1),M(this.m_inputSR,0,[o],1),s=this.m_envHelper.calculateBbox(n.x,n.y,o.x,o.y)}return i.set(e,s),s}return i.get(e)}findOrComputeBoxPoint(e,t,i,s){if(!s.has(e)){let n=T();return n.setCoords({xmin:t.x,ymin:t.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(n=this.m_envHelper.calculateBbox(n.xmin,n.ymin,n.xmax,n.ymax)),s.set(e,n),n}return s.get(e)}estimateMinimumDistance(e,t){const i={stack:[],error:void 0,hasError:!1};try{const s=c=>R(this.m_a,this.m_eSquared,c),n=this.m_boundaryPtsA.map(s),o=this.m_boundaryPtsB.map(s);let a=Number.MAX_VALUE,m=0,r=0;for(let c=0;c<n.length;++c)for(let h=0;h<o.length;++h){const g=E.distance(n[c],o[h]);g<a&&(a=g,m=c,r=h)}e.outPoint.assign(this.m_boundaryPtsA[m]),t.outPoint.assign(this.m_boundaryPtsB[r]);const u=C(i,new b,!1);return w.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[m].x,this.m_boundaryPtsA[m].y,this.m_boundaryPtsB[r].x,this.m_boundaryPtsB[r].y,u,null,null,this.m_distCurveType),u.val}catch(s){i.error=s,i.hasError=!0}finally{q(i)}}swapGeometries(e,t){return it(e[0])>it(t[0])&&(t[0]=$(e[0],e[0]=t[0]),this.m_envGeomB=$(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(e,t){return!1}checkGeometriesIntersect(e,t,i,s){let n=e.getGeometryType(),o=t.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(n===_.enumPoint&&t.getDimension()===2){const c=[0],h=[e.getXY()];if(Q(t,h,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(h[0]),s.outPoint.assign(h[0]),!0}else if(o===_.enumPoint&&e.getDimension()===2){const c=[2],h=[t.getXY()];if(Q(e,h,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(h[0]),s.outPoint.assign(h[0]),!0}if(n===_.enumMultiPoint&&t.getDimension()===2)return this.multipointIntersectsArea(e,t,i,s);if(o===_.enumMultiPoint&&e.getDimension()===2)return this.multipointIntersectsArea(t,e,s,i);let a,m,r=e,u=t;if(n===_.enumEnvelope&&(a=this.envelopeToPolygon(e),r=a,n=_.enumPolygon),o===_.enumEnvelope&&(m=this.envelopeToPolygon(t),u=m,o=_.enumPolygon),st(n)&&st(o)){const c=r.querySegmentIterator(),h=u.querySegmentIterator(),g=ot(),d=ot();if(ft(r,u,c,h,g,d))return i.outPoint.assign(g.outPoint),s.outPoint.assign(g.outPoint),!0}}return!1}multipointIntersectsArea(e,t,i,s){const n=e.getPointCount();for(let o=0;o<n;++o){const a=[2],m=e.getXY(o);if(Q(t,[m],1,this.m_tolerance,a),a[0]!==0)return i.outPoint.assign(m),s.outPoint.assign(m),!0}return!1}getNearestNeighbourVisitor(e,t,i,s,n,o,a){return Y(0),{}}buildSpatialTree(e,t){Y(0)}}export{Rt as J,Xt as Q,mt as j};
