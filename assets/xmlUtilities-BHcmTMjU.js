const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-D-T3_AF4.js","assets/index-Bkom2Sdc.js","assets/index-CkucmIUh.css","assets/Point2D-DVg-Qhcx.js","assets/ProjectionTransformation-Bvt2x7E-.js","assets/Envelope2D-7paLNnHT.js","assets/Transformation2D-CNf0ySKF.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-74r_fa1M.js","assets/apiConverter-C8FhisLI.js","assets/differenceOperator-0W3YboAc.js","assets/lengthOperator-CeaRrJ67.js"])))=>i.map(i=>d[i]);
import{b6 as Fe,fb as Z,n7 as Ie,bf as re,b4 as $,dP as Y,a$ as B,bN as U,bH as Re,i4 as De,aY as be,dc as Be,n8 as Ce,b8 as I,ba as b,hz as we,bb as le,f8 as ze,aH as ee,dR as He,i3 as $e,b9 as Je,eC as Ne,a_ as Me}from"./index-Bkom2Sdc.js";import{t as M,y as Se,C as Ee,n as Oe,s as We,a as Le,p as ve,g as qe,v as ue,U as Ae,D as Ge,b as Ve}from"./datasetUtils-BHf95nQl.js";import{u as je,N as he,p as Ue,l as Qe,d as Xe,j as Ye,D as me,h as Ke,a as Ze,b as et,q as tt,W as it,z as nt,B as de,c as rt,i as fe}from"./RasterJobHandlerMixin-CXgaqaNL.js";import{R as st,l as at,k as ot,O as lt,a as ct}from"./RasterSymbolizer-BQJRaC-o.js";import{QueueProcessor as ut}from"./QueueProcessor-DqRCcjoo.js";import{i as ht,m as mt,h as dt,x as ft,s as pt}from"./RawBlockCache-mSZxM6gY.js";import{T as ie,N as _e,D as yt,a as xt,l as gt}from"./vectorFieldUtils-DYAo00Wy.js";import{$ as X,j as se,W as pe,f as ye,c as It,n as ne,H as K,r as Rt,i as bt,C as wt,Q as ae}from"./rasterProjectionHelper-De1k5S3R.js";import{r as oe,p as St}from"./clipUtils-Dy_nqovQ.js";import{T as vt}from"./rasterFunctionHelper-y-UIL_9j.js";const xe=8,_t=256;let Tt=0,S=class extends Fe{constructor(){super(...arguments),this._tileFetchQueue=new ut({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Z.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=X(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),M(this)&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+Tt++}set url(t){this._set("url",Ie(t,re.getLogger(this)))}async open(t){return this._openPromise??=se().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,s,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(t,i,s,n);if(!a)throw new $("imagery-tile:out-of-bounds","Level for fetch tile out of range");return e={noClip:!0,...e},this.fetchPixels(a,n.size[0],n.size[1],e)}async identify(t,i={}){t=Y(B,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:r}=n;let{transposedVariableName:l}=i;const o=r!=null&&a&&(e!=null||Se(s));o&&!l&&(l=s!=null&&s.length>0?s[0].variableName??void 0:r.variables[0].name,i={...i,transposedVariableName:l}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=n,{datumTransformation:m}=i;let h=pe(t,c,m);if(!u.intersects(h))return{location:h,value:null};if(n.transform!=null){const F=n.transform.inverseTransform(h);if(!n.nativeExtent.intersects(F))return{location:F,value:null};h=F}let f=0;const y=l!=null&&r!=null&&n.hasMultidimensionalTranspose;if(M(this)){const F=this.primaryRasters.rasters[0];if(y)return F.identify(h,i);const{pixelSize:W}=n,_=3,H=W.x*_/2,L=W.y*_/2,q=new U({xmin:h.x-H,xmax:h.x+H,ymin:h.y-L,ymax:h.y+L,spatialReference:c}),A={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:k}=await F.fetchPixels(q,_,_,A),{pixelBlock:T}=await this.fetchPixels(q,_,_,A);if(k==null)return{location:h,value:null};const D=Math.floor(_*_*.5),J=!k.mask||k.mask[D]?k.pixels.map(C=>C[D]):null;let E;return T!=null&&(E=!T.mask||T.mask[D]?T.pixels.map(C=>C[D]):void 0),{location:h,value:J,processedValue:E,pyramidLevel:0}}if(!y){if(i.srcResolution)f=ye(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(t,i),f==null)return{location:h,value:null}}const R=this.identifyPixelLocation(h,f,null,y);if(R===null)return{location:h,value:null};const{row:d,col:p,rowOffset:g,colOffset:w,blockWidth:v}=R,P=await this._tileFetchQueue.push({pyramidLevel:f,row:d,col:p,options:i},{signal:i.signal});if(!P?.pixels?.length)return{location:h,value:null};const z=g*v+w;return this._processIdentifyResult(P,{srcLocation:h,position:z,pyramidLevel:f,useTransposedTile:!!y,requestSomeSlices:o,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=It(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,s,e);const a=X(t.spatialReference),r=ne(t);if(a==null||r===0||r===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,s,e);if(r>=3)return{extent:t,pixelBlock:null};const l=[],{xmin:o,xmax:c}=t,u=Math.round(a/(c-o)*i),m=u-Math.round((a/2-o)/(c-o)*i);let h=0;const f=[];for(let p=0;p<=r;p++){const g=new U({xmin:p===0?o:-a/2,xmax:p===r?c-a*p:a/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),w=p===0?u-m:p===r?i-h:u;h+=w,f.push(w);const v=e.disableWrapAround&&p>0?null:this._fetchPixels(g,w,s,e);l.push(v)}const y=(await Promise.all(l)).map(p=>p?.pixelBlock);let R=null;const d={width:i,height:s};return this.rasterJobHandler?R=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},e)).pixelBlock:R=ie(y,d,{blockWidths:f}),{extent:t,srcExtent:K(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:R}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,s,e),{nativeExtent:a,nativePixelSize:r,storageInfo:l}=this.rasterInfo,o=2**t,c=r.x*o,u=r.y*o,m=new U({xmin:a.xmin+c*i.x,xmax:a.xmin+c*(i.x+s.width-1),ymin:a.ymax-u*(i.y+s.height-1),ymax:a.ymax-u*i.y,spatialReference:a.spatialReference});if(!n)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:h,mosaicSize:f}=n;if(h.length===1&&h[0]!=null&&h[0].width===s.width&&h[0].height===s.height)return{extent:m,srcExtent:m,pixelBlock:n.pixelBlocks[0]};const y=t>0?l.pyramidBlockWidth:l.blockWidth,R=t>0?l.pyramidBlockHeight:l.blockHeight,d={x:i.x%y,y:i.y%R};let p;return this.rasterJobHandler?p=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:f,destDimension:s,clipOffset:d,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:p=ie(h,f,{clipOffset:d,clipSize:s}),{extent:m,srcExtent:m,pixelBlock:p}}fetchRawTile(t,i,s,e){throw new $("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return K(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?st(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:a,headers:r}=i;s=s??i.retryCount??this.ioConfig.retryCount;const l=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Re(t,{...i,query:{...a,...e},headers:{...r,...l}})}catch(o){if(s>0)return s--,this.request(t,i,s);throw o}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Ee(t,i)}getTileExtentFromTileInfo(t,i,s,e){const n=e.lodAt(t);return n?this.getTileExtent({x:n.resolution,y:n.resolution},i,s,e.origin,e.spatialReference,e.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const a=[],r=t.maximumPyramidLevel||0;let l=(e.x+e.y)/2,o=1/.0254*96*l;for(let u=0;u<=r&&(a.unshift(new De({level:r-u,resolution:l,scale:o})),u!==r);u++)if(n){const m=(n[u].x+n[u].y)/2;o*=m/l,l=m}else l*=2,o*=2;const c=new B({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new Z({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:a}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){const{width:n,height:a,nativeExtent:r,pixelSize:l,spatialReference:o}=t,c=new B({x:r.xmin,y:r.ymax,spatialReference:o});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,a))/Math.LN2-8)));const u=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[l],e);t.storageInfo=new at({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,n,a=0,r=2){if(n.length===1&&a>0){n=[...n];let{x:u,y:m}=n[0];for(let h=0;h<a;h++)u*=r,m*=r,n.push({x:u,y:m})}const l=[],{x:o,y:c}=e;for(let u=0;u<n.length;u++){const{x:m,y:h}=n[u];l.push({minCol:Math.floor((t.xmin-o+.1*m)/i/m),maxCol:Math.floor((t.xmax-o-.1*m)/i/m),minRow:Math.floor((c-t.ymax+.1*h)/s/h),maxRow:Math.floor((c-t.ymin-.1*h)/s/h)})}return l}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,s,e){const{spatialReference:n,nativeExtent:a,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:l,origin:o,transposeInfo:c}=r,u=e&&c!=null?c.tileSize[0]:r.blockWidth,m=e&&c!=null?c.tileSize[1]:r.blockHeight,h=pe(t,n,s);if(!a.intersects(h)||i<0||i>l)return null;const f=this.getPyramidPixelSize(i),{x:y,y:R}=f,d=(o.y-h.y)/R/m,p=(h.x-o.x)/y/u,g=Math.min(m-1,Math.floor((d-Math.floor(d))*m)),w=Math.min(u-1,Math.floor((p-Math.floor(p))*u));return{pyramidLevel:i,row:Math.floor(d),col:Math.floor(p),rowOffset:g,colOffset:w,blockWidth:u,srcLocation:h}}getTileExtent(t,i,s,e,n,a){const[r,l]=a,o=e.x+s*r*t.x,c=o+r*t.x,u=e.y-i*l*t.y,m=u-l*t.y;return new U({xmin:o,xmax:c,ymin:m,ymax:u,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:e}=t,n=be.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new B({x:1,y:1,spatialReference:n});const{extent:a,storageInfo:r}=t;if(r){r.origin=new B({x:a.xmin,y:a.ymax,spatialReference:n});const{pyramidResolutions:l,tileInfo:o}=r;if(l&&l.forEach(c=>{c.x/=i.x,c.y/=i.y}),o){o.origin=r.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;o.lods.forEach((u,m)=>{u.resolution=c*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let n=ne(t);if(n>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:r,srcResolution:l,srcExtent:o,srcWidth:c,srcHeight:u,ul:m}=a;if(c===0||u===0)return{extent:t,srcExtent:o,pixelBlock:null};const{rasterInfo:h}=this,f=h.transform,y=f?.type==="gcs-shift",R=X(t.spatialReference)!=null;!y&&R||(n=ne(a.srcExtent,y));const d=await this._fetchRawTiles(r,m,{width:c,height:u,wrapCount:n},e);if(!d)return{extent:t,srcExtent:o,pixelBlock:null};const p=h.storageInfo,g=r>0?p.pyramidBlockWidth:p.blockWidth,w=r>0?p.pyramidBlockHeight:p.blockHeight;let{x:v,y:P}=h.pixelSize;if(r>0){const{pyramidResolutions:N,pyramidScalingFactor:Pe}=p;if(N!=null&&N[r-1])({x:v,y:P}=N[r-1]);else{const ce=Pe**r;v*=ce,P*=ce}}const z=h.spatialReference,F=new B({x:v,y:P,spatialReference:z}),W=g===c&&w===u&&m.x%g===0&&m.y%w===0,_=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),H=!t.spatialReference.equals(z),L=z.isGeographic?1e-9:1e-4,{datumTransformation:q}=e;if(!H&&W&&d.pixelBlocks.length===1&&g===i&&w===s&&kt(l,_,L))return{extent:t,srcExtent:o,srcTilePixelSize:F,pixelBlock:d.pixelBlocks[0]};const A=R&&X(o.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,k=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");k&&!this.rasterJobHandler&&await se();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:_.toJSON(),datumTransformation:q,rasterTransform:f,hasWrapAround:n>0||A,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:k},e):Rt({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:_,datumTransformation:q,rasterTransform:f,hasWrapAround:n>0||A,isAdaptive:!1,includeGCSGrid:k});let D;const J=!e.requestRawData,E={rows:T.spacing[0],cols:T.spacing[1]},C=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,d.extent.xmin):void 0,{pixelBlocks:O,mosaicSize:G,isPartiallyFilled:Q}=d;let V=null;if(this.rasterJobHandler)({pixelBlock:D,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:G,destDimension:J?{width:i,height:s}:null,coefs:J?T.coefficients:null,sampleSpacing:J?E:null,projectDirections:k,gcsGrid:k?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:C,blockWidths:null},e));else{const N=ie(O,G,{alignmentInfo:C});D=J?_e(N,{width:i,height:s},T.coefficients,E,e.interpolation):N,k&&T.gcsGrid&&(V=yt({width:i,height:s},T.gcsGrid),D=xt(D,this.rasterInfo.dataType,V))}return e.requestRawData||k?{extent:t,srcExtent:o,srcTilePixelSize:F,pixelBlock:D,transformGrid:T,localNorthDirections:V,isPartiallyFilled:Q}:{extent:t,srcExtent:o,srcTilePixelSize:F,pixelBlock:D}}async _fetchRawTiles(t,i,s,e){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:l}=this.getBlockWidthHeight(t);let{x:o,y:c}=i,{width:u,height:m,wrapCount:h}=s;const f=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(o-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,m+=2*e.buffer.rows);let y=0,R=0,d=0;h&&f!=null&&({worldColumnCountFromOrigin:R,originColumnOffset:d,rightPadding:y}=f,R*f.blockWidth-y>=o+u&&(y=0));const p=Math.floor(o/r),g=Math.floor(c/l),w=Math.floor((o+u+y-1)/r),v=Math.floor((c+m+y-1)/l),P=a[t];if(!P)return null;const{minRow:z,minCol:F,maxCol:W,maxRow:_}=P;if(h===0&&(v<z||w<F||g>_||p>W))return null;const H=new Array;let L=!1;const q=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let C=g;C<=v;C++)for(let O=p;O<=w;O++){let G=O;if(!e.disableWrapAround&&h&&f!=null&&R<=O&&(G=O-R-d),C>=z&&G>=F&&_>=C&&W>=G){const Q=this._tileFetchQueue.push({pyramidLevel:t,row:C,col:G,options:e},{signal:e.signal});q?H.push(new Promise(V=>{Q.then(N=>V(N)).catch(()=>{L=!0,V(null)})})):H.push(Q)}else H.push(Promise.resolve(null))}if(H.length===0)return null;const A=await Promise.all(H),k={height:(v-g+1)*l,width:(w-p+1)*r},{spatialReference:T}=this.rasterInfo,D=this.getPyramidPixelSize(t),{x:J,y:E}=D;return{extent:new U({xmin:n.x+p*r*J,xmax:n.x+(w+1)*r*J,ymin:n.y-(v+1)*l*E,ymax:n.y-g*l*E,spatialReference:T}),pixelBlocks:A,mosaicSize:k,isPartiallyFilled:L}}_fetchRawTile(t,i,s,e){const{storageInfo:n}=this.rasterInfo,a=n.transposeInfo!=null&&!!e.transposedVariableName;if(!a){const m=n.blockBoundary[t];if(!m)return Promise.resolve(null);const{minRow:h,minCol:f,maxCol:y,maxRow:R}=m;if(i<h||s<f||i>R||s>y)return Promise.resolve(null)}const r=a?e.transposeVariableName:e.sliceId,l=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,o=ht(this.rasterId,r,l),c=`${t}/${i}/${s}`;let u=mt(o,e.registryId,c);if(u==null){const m=new AbortController;u=this.fetchRawTile(t,i,s,{...e,signal:m.signal}),dt(o,e.registryId,c,u,m),u.catch(()=>ft(o,e.registryId,c))}return e.signal&&Be(e,()=>{pt(o,e.registryId,c)}),u}_computeMagDirValues(t){const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||t?.length!==2||!t[0]?.length)return null;const e=t[0].length;if(s==="vector-magdir"){const o=t[1].map(c=>(c+360)%360);return[t[0],o]}const[n,a]=t,r=[],l=[];for(let o=0;o<e;o++){const[c,u]=gt([n[o],a[o]]);r.push(c),l.push(u)}return[r,l]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=bt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:l,pyramidLevel:o}=n,c=r/i,u=l/s,m=o<a&&c*u>=16,h=o===a&&this._requireTooManySrcTiles(r,l,i,s);if(m||h||r===0||l===0){const f=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let y=wt(f,this.rasterInfo.spatialReference,t,n.datumTransformation);const R=!y||e.srcResolution&&y.x+y.y<e.srcResolution.x+e.srcResolution.y;if(m&&e.srcResolution&&R){const d=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(a-o+3>=d){const p=2**d;y={x:e.srcResolution.x*p,y:e.srcResolution.y*p}}}y&&(n.srcResolution=y,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,s)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,s,e){const{tileInfo:n}=this.rasterInfo.storageInfo,a=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),r=t/s,l=i/e,o=Math.max(1,(s+e)/1024);return a>=_t*o||r>xe||l>xe}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:n,datumTransformation:a}=i,{pyramidLevel:r,pyramidResolution:l,excessiveReading:o}=ye(n,s,this.ioConfig.sampling);if(o)return;let c=i.srcExtent||K(t,e,a);if(c==null)return;const u=s.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:m}=s.storageInfo,{width:h,height:f,ul:y}=Oe(c,m,l,r);i.pyramidLevel=r,i.pyramidResolution=l,i.srcWidth=h,i.srcHeight=f,i.ul=y}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:e,pyramidLevel:n,useTransposedTile:a}=i,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(l==null||!a){const d=t.pixels.map(w=>w[e]),p={location:s,value:d,pyramidLevel:n},g=this._computeMagDirValues(d.map(w=>[w]));return g?.length&&(p.magdirValue=g.map(w=>w[0])),p}let o=t.pixels.map(d=>d.slice(e*r,e*r+r)),c=this._computeMagDirValues(o);const{requestSomeSlices:u,identifyOptions:m}=i;let h=We(l,m.transposedVariableName);if(u){const d=Le(h,m.multidimensionalDefinition,m.timeExtent);o=o.map(p=>d.map(g=>p[g])),c=c?.map(p=>d.map(g=>p[g])),h=d.map(p=>h[p])}const f=t.noDataValues||this.rasterInfo.noDataValue,y={pixels:o,pixelType:t.pixelType};let R;return f!=null&&(Ce(y,f),R=y.mask),{location:s,value:null,dataSeries:h.map((d,p)=>{const g={value:R?.[p]===0?null:o.map(w=>w[p]),multidimensionalDefinition:d.multidimensionalDefinition.map(w=>new ve({...w,isSlice:!0}))};return c?.length&&(g.magdirValue=[c[0][p],c[1][p]]),g}),pyramidLevel:n}}};function kt(x,t,i){return Math.abs(x.x-t.x)<i&&Math.abs(x.y-t.y)<i}I([b()],S.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],S.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],S.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],S.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],S.prototype,"_openPromise",void 0),I([b()],S.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],S.prototype,"rasterId",null),I([b(we)],S.prototype,"url",null),I([b({type:String,json:{write:!0}})],S.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],S.prototype,"datasetFormat",void 0),I([b()],S.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],S.prototype,"rasterInfo",void 0),I([b()],S.prototype,"ioConfig",void 0),I([b()],S.prototype,"sourceJSON",void 0),S=I([le("esri.layers.support.rasterDatasets.BaseRaster")],S);const Pt=40;let j=class extends S{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(x,t,i,s={}){const{rasters:e,rasterIds:n}=this.primaryRasters;let a=!1;const{interpolation:r}=s,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&l&&(a=e.length===1&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:a}),s.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,s={...s,requestRawData:!1});const o=e.map(g=>g.fetchPixels(x,t,i,s)),c=await Promise.all(o),u=c.map(g=>g.pixelBlock),m=a||s.requestRawData?c.map(g=>g.srcTilePixelSize):null;if(s.skipRasterFunction||u.every(g=>g==null))return c[0];const h=c.find(g=>g.pixelBlock!=null)?.extent??x;let f=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:u,primaryPixelSizes:m,primaryRasterIds:n}):this.rasterFunction.process({extent:h,primaryPixelBlocks:u,primaryPixelSizes:m,primaryRasterIds:n});const{transformGrid:y}=c[0];if(!a||f==null||y==null){const g=s.noClip?null:this.getClippingGeometry(h.spatialReference);return!s.noClip&&f!=null&&g&&(f=await oe(f,h,g)),{...c[0],pixelBlock:f}}const R={rows:y.spacing[0],cols:y.spacing[1]};let d;this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[f],srcMosaicSize:{width:f.width,height:f.height},destDimension:{width:t,height:i},coefs:y.coefficients,sampleSpacing:R,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:r,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:d=_e(f,{width:t,height:i},y.coefficients,R,r);const p=s.noClip?null:this.getClippingGeometry(x.spatialReference);return s.noClip||d==null||p==null||(d=await oe(d,x,p)),{extent:x,srcExtent:c[0].srcExtent,pixelBlock:d}}getClippingGeometry(x){const t=this._clippingGeometry.get("0");if(!x||!t)return t;const i=Dt(x);let s=this._clippingGeometry.get(i);return s!=null||(s=x.equals(t.spatialReference)?t:ae(t,x),this._clippingGeometry.set(i,s)),s}async _open(x){const{rasterFunction:t}=this;t.isRoot=!0,this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(o=>o.rasterJobHandler=this.rasterJobHandler));const{rasters:i,rasterIds:s}=this.primaryRasters,e=i.map(o=>o.rasterInfo?void 0:o.open(x));await Promise.all(e);const n=i.map(({rasterInfo:o})=>o),a=t.bind({rasterInfos:n,rasterIds:s});if(t.rawSourceRasterInfos=n,!a.success||n.length===0)throw new $("raster-function:open",`cannot bind the function: ${a.error??""}`);const r=t.functionName==="Table"?t:t.functionArguments?.raster;r?.functionName==="Table"&&(t.rasterInfo.attributeTable=ze.fromJSON(r.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=n[0];this.hasUniqueSourceStorageInfo=n.length===1||n.slice(1).every(o=>Ft(o,l)),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const x=this.rasterFunction.getClippingGeometries()[0];let t=x?.clippingGeometry;if(t&&x.clippingType==="inside"){const{extent:i}=this.rasterInfo,s=await ee(()=>import("./densifyOperator-D-T3_AF4.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10])),e=await ee(()=>import("./differenceOperator-0W3YboAc.js").then(a=>a.d),__vite__mapDeps([11,3,4,5,6,7,1,2,8,9,10]));let n=s.execute(He.fromExtent(i),2*(i.width+i.height)/Pt);n=ae(n,t.spatialReference),t=e.execute(n,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};function Ft(x,t){const{storageInfo:i,pixelSize:s,spatialReference:e,extent:n}=x,{storageInfo:a,pixelSize:r,spatialReference:l,extent:o}=t;return s.x===r.x&&s.y===r.y&&e.equals(l)&&n.equals(o)&&i.blockHeight===a.blockHeight&&i.blockWidth===a.blockWidth&&i.maximumPyramidLevel===a.maximumPyramidLevel&&i.firstPyramidLevel===a.firstPyramidLevel&&i.pyramidBlockWidth===a.pyramidBlockWidth&&i.pyramidBlockHeight===a.pyramidBlockHeight&&i.pyramidScalingFactor===a.pyramidScalingFactor}function Dt(x){return String(x.wkid??x.wkt??x.wkt2)}I([b({type:String,json:{write:!0}})],j.prototype,"datasetFormat",void 0),I([b()],j.prototype,"tileType",void 0),I([b()],j.prototype,"rasterFunction",void 0),I([b()],j.prototype,"primaryRasters",void 0),j=I([le("esri.layers.support.rasterDatasets.FunctionRaster")],j);const ge=1e3,qt=x=>{const t=x;let i=class extends t{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=M(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Ie(e,re.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?n?.find(({name:r})=>r===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){const r=n?.layerDefinition?.drawingInfo?.renderer;return Xe(r,a)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=Y(Ye,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=r;const{spatialReference:o}=a;if(!r.spatialReference.equals(o)){await se();const d=r.type==="extent"?K(r,o):ae(r,o);if(d==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=d}const c=e.pixelSize??new B({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:o}),{extent:u,width:m,height:h}=St(a,l,c),f=await this.fetchPixels(u,m,h,{...n,interpolation:"nearest"});if(f.pixelBlock==null)throw new $("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const y=await oe(f.pixelBlock,u,l),R=this._rasterJobHandler;return R?R.computeStatisticsHistograms({pixelBlock:y},n):ot(y)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=qe({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:a}=this;if(!e||!n||!a)return;const{rasterInfo:r}=this.raster,l=ue(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=l?.name,c=me(r,o);return this._updateSymbolizer(n,a,o,c)}async applyRenderer(e,n,a){const r=e?.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:o}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:l,symbolizer:this.symbolizer},a);return o}getRawDisplayBandIds(){let{bandIds:e,raster:n}=this;if(this.rasterFunction&&M(n)){const a=n.rasterFunction.rawInputBandIds;e=e?.length&&a?.length&&n.rasterInfo.bandCount!==1?e.map(r=>a[Math.min(r,a.length-1)]):a}return e&&e.length>3&&e.every((a,r)=>a===r)?null:e}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const r=Me(e);return Z.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,r={}){if(s(this),r.requestAsImageElement){const o=this.getTileUrl(e,n,a);return Re(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(c=>c.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const o=r.tileInfo||l.storageInfo.tileInfo,c=this.raster.getTileExtentFromTileInfo(e,n,a,o);if(c)return{extent:c,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,r)}async fetchPixels(e,n,a,r={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a);const l=await this.raster.fetchPixels(e,n,a,r);return r.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=l.pixelBlock?.extractBands(r.bandIds)),l}async getSamples(e,n){if(await this.load(),(e=Y(Ke,e).clone()).interpolation&&e.interpolation!=="nearest")throw new $("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=e.mosaicRule?.multidimensionalDefinition,r={...n,multidimensionalDefinition:a},l=(await this._getSampleLocations(e)).map(c=>this.identify(c,r).then(u=>(u.location=c,u))),o=(await Promise.all(l)).flatMap((c,u)=>this._convertRasterIdentifyResultToSample(c,u));return new Ze({samples:o})}async identify(e,n={}){await this.load(),e=Y(B,e).clone().normalize();const{raster:a,serviceRasterInfo:r}=this;if(r?.multidimensionalInfo!=null&&!(r.hasMultidimensionalTranspose&&!(!Se(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const l=this.multidimensionalSubset?.areaOfInterest;if(l&&!l.contains(e))throw new $("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let o;if(this.serviceRasterInfo?.storageInfo.isBsqTile){const c=M(a)?this.getRawDisplayBandIds():this.bandIds;o=c?.length?c:void 0}return a.identify(e,{...n,bandIds:o})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=n?.[0]?.variableName;return e.variables.some(r=>r.name===a&&(!n?.[0].dimensionName||r.dimensions.some(l=>l.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ae(e)).toISOString()}getMultidimensionalSubsetVariables(e){const n=e??this.serviceRasterInfo?.multidimensionalInfo;return Ge(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ve(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&M(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;s(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,M(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:a,type:r}=n;if(r==="multipoint")return n.points.map(d=>new B({x:d[0],y:d[1],spatialReference:a}));if(r==="polyline"){let d=n;if(e.sampleCount||e.sampleDistance){const p=await ee(()=>import("./densifyOperator-D-T3_AF4.js").then(P=>P.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10])),g=(await ee(async()=>{const{execute:P}=await import("./lengthOperator-CeaRrJ67.js").then(z=>z.l);return{execute:P}},__vite__mapDeps([12,1,2,3,5,4,6,7,8,9,10]))).execute(n,{unit:"meters"}),w=Math.min(e.sampleCount||100,ge);let v=e.sampleDistance;v||(v=g/(w+(d.paths[0].length===2?1:0))),d=p.execute(n,v,{unit:"meters"})}return d.paths.flatMap(p=>p.map(g=>new B({x:g[0],y:g[1],spatialReference:a})))}const l=Math.min(e.sampleCount||100,ge),o=n.type==="extent",c=o?n:n.extent,u=Math.sqrt(c.width*c.height/l),m=c.height/u,h=c.width/u,{xmin:f,ymax:y}=c,R=[];for(let d=0;d<m;d++)for(let p=0;p<h;p++){const g=new B({x:f+(p+.5)*u,y:y-(d+.5)*u,spatialReference:a});(o||n.contains(g))&&R.push(g)}return R}_configDefaultInterpolation(){if(this.interpolation==null){s(this);const{raster:e}=this,n=et(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(e="no"){s(this);const{rasterInfo:n}=this.raster,a=ue(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=a?.name,l=tt({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=l?.bandIds??it(n)),!this.renderer||e==="override"){const m=nt(this.raster),h=l?.renderer??de(n,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:m}),f=n.statistics,y=f&&f.length>0?f[0]:null,R=y?.max??0,d=y?.min??0;this.raster.datasetFormat==="WCSServer"&&h.type==="raster-stretch"&&(R>1e24||d<-1e24)&&(h.dynamicRangeAdjustment=!0,h.customStatistics=null,h.stretchType==="none"&&(h.stretchType="min-max")),this.renderer=h}const o=rt({...this.renderer.toJSON(),variableName:r}),c=me(n,r);this.symbolizer?(this.symbolizer.rendererJSON=o,this.symbolizer.rasterInfo=c):this.symbolizer=new lt({rendererJSON:o,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:m}=this.raster.rasterInfo,h=this.renderer;if(m!=null&&h.type==="raster-colormap"){const f=de(this.raster.rasterInfo);JSON.stringify(f)!==JSON.stringify(h)&&this._configDefaultRenderer("override")}else if(h.type==="raster-stretch"){const f=this.bandIds?.length,y=h.customStatistics?.length;!h.dynamicRangeAdjustment&&y&&f&&y!==f&&this._configDefaultRenderer("override")}}}else re.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&M(this.raster)){const u=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&u&&this._set("rasterFunction",he.fromJSON(u)))}let e,n=this.raster,a=!1;M(n)?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:r}=this;if(r){const u={raster:n};e.length>1&&e.forEach(f=>u[f.url]=f);const m=vt(r.functionDefinition?.toJSON()??r.toJSON(),u),h=new j({rasterFunction:m});h.rasterJobHandler=this._rasterJobHandler,await h.open(),this.raster=h}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!a&&!r)return;const{bandIds:l}=this,{bandCount:o}=this.raster.rasterInfo,c=l?.length?l.some(u=>u>=o):o>=3;l&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){const{rasterInfo:a}=this.raster,r=a.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),l=(a.pixelSize.x+a.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new fe({location:e.location,pixelValue:e.value,locationId:n,resolution:l})];const o=[];return e.dataSeries.forEach(({value:c,multidimensionalDefinition:u},m)=>{const h={Variables:u[0].variableName,Dimensions:u.flatMap(({dimensionName:y})=>y).join(",")};for(const{dimensionName:y,values:R}of u){h[y]=Array.isArray(R[0])?R[0][0]:R[0];const d=R[R.length-1];h[`${y}_Max`]=Array.isArray(d)?d[d.length-1]:d}const f=new fe({location:e.location,pixelValue:c,rasterId:m,locationId:n,resolution:l,attributes:h});o.push(f)}),o}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new $("imagery-tile","no raster")}return I([b({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[$e],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),I([b({json:{read:!1}})],i.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(ct)],i.prototype,"interpolation",void 0),I([b()],i.prototype,"ioConfig",void 0),I([b({type:[ve],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),I([b({type:je,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),I([b()],i.prototype,"raster",void 0),I([b({type:he})],i.prototype,"rasterFunction",null),I([b()],i.prototype,"serviceRasterInfo",void 0),I([b()],i.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:be,json:{read:!1}})],i.prototype,"spatialReference",void 0),I([b({type:Z})],i.prototype,"tileInfo",void 0),I([b(we)],i.prototype,"url",null),I([b()],i.prototype,"renderer",null),I([b({types:Qe,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ue,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],i.prototype,"internalRenderer",null),I([Ne("internalRenderer")],i.prototype,"readRenderer",null),I([b({clonable:!1})],i.prototype,"symbolizer",void 0),i=I([le("esri.layers.mixins.ImageryTileMixin")],i),i};function te(x,t){if(!x||!t)return[];let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=[];if(t){const n=te(x,i);for(let a=0;a<n.length;a++)te(n[a],t).forEach(r=>s.push(r));return s}const e=x.getElementsByTagNameNS("*",i);if(!e||e.length===0)return[];for(let n=0;n<e.length;n++)s.push(e[n]||e.item(n));return s}function Te(x,t){if(!x||!t)return null;let i=t;t.includes("/")?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=te(x,i);return s.length>0?t?Te(s[0],t):s[0]:null}function ke(x,t=null){const i=t?Te(x,t):x;let s;return i?(s=i.textContent||i.nodeValue,s?s.trim():null):null}function Bt(x,t){const i=te(x,t),s=[];let e;for(let n=0;n<i.length;n++)e=i[n].textContent||i[n].nodeValue,e&&(e=e.trim(),e!==""&&s.push(e));return s}function At(x,t=null){return ke(x,t)?.split(" ").map(s=>Number(s))??[]}function Gt(x,t){return Bt(x,t).map(i=>Number(i))}function Vt(x,t){const i=ke(x,t);return Number(i)}function jt(x,t){const i=x?.nodeName?.toLowerCase(),s=t.toLowerCase();return i.slice(i.lastIndexOf(":")+1)===s}function Ut(x){return x.nodeName.slice(x.nodeName.lastIndexOf(":")+1)}export{S as X,qt as a,Ut as c,Te as e,jt as i,Bt as l,j as m,te as n,Vt as o,At as r,ke as t,Gt as u};
